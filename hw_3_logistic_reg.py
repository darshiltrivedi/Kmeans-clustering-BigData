# -*- coding: utf-8 -*-
"""HW_3_logistic_Reg.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11GSlSzpk9A1Z_E1f9574IxklYr1QvqiQ
"""

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
# import random as rd


mnist = tf.keras.datasets.mnist
(train_images, train_labels),(test_images, test_labels)=mnist.load_data()
index_train=np.where((train_labels ==3)| (train_labels ==5))
index_test=np.where((test_labels ==3)| (test_labels ==5))
train_images_35=train_images[index_train]
train_images_35=train_images_35.reshape((len(train_images_35), train_images_35[1].size))
train_labels_35=train_labels[index_train].astype('int')
test_images_35=test_images[index_test]
test_images_35=test_images_35.reshape((len(test_images_35), test_images_35[1].size))
test_labels_35=test_labels[index_test].astype('int')
train_labels_35[np.where(train_labels_35==3)]= -1
train_labels_35[np.where(train_labels_35==5)]= 1
test_labels_35[np.where(test_labels_35==3)]= -1
test_labels_35[np.where(test_labels_35==5)]= 1


train_images_35_w_dummy=np.insert(train_images_35,784,1,axis=1)/255
test_images_35_w_dummy=np.insert(test_images_35,784,1,axis=1)/255

train_images_35_hw3=train_images_35_w_dummy[range(2000)]
train_labels_35_hw3=train_labels_35[range(2000)]
test_images_35_hw3=test_images_35_w_dummy
test_labels_35_hw3=test_labels_35
# print(train_images_35_hw3.shape)
# print(test_images_35_hw3.shape)
# print(train_labels_35_hw3)
# print(test_labels_35_hw3)

train_labels_35_hw3[train_labels_35_hw3 == 1] =0 
train_labels_35_hw3[train_labels_35_hw3 == -1] =1 
test_labels_35_hw3[test_labels_35_hw3 == 1] =0
test_labels_35_hw3[test_labels_35_hw3 ==-1] =1
# print(train_labels_35_hw3)
# print(test_labels_35_hw3)

theta = np.zeros((785,1))
# print(theta)
alpha = 0.5
gamma = 0.5
# x = np.dot(theta.T, train_images_35_hw3.T)
# x = theta.T*train_images_35_hw3
# # print(x.shape)
h_theta = np.zeros((785,1))
# print(h_theta)

count = 0
loss = 0
test_loss = 0
delta_theta = 1#np.ones((2000,785)).sum()


#Batch Gradient

while abs(delta_theta) > 0.01:
  # print(delta_theta)  
  for i in range(len(train_images_35_hw3)):
    x= (theta.T*train_images_35_hw3[i])
    h_theta = 1/(1 + np.exp(-x))
    delta_theta = np.sum([((train_labels_35_hw3[i] - h_theta)*train_images_35_hw3[i])])#.sum()
  # print(delta_theta)
  theta = theta + (alpha*delta_theta)
  count = count + 1
print('The total numbers of itterations are ' + str(count))
# print(theta)

y_cap = np.empty(2000,)
y_cap_test = np.empty(2000,)

for i in range(len(train_images_35_hw3)):
  if np.sum((theta.T*train_images_35_hw3[i])) >=0:
    y_cap[i] = 0 
  else:
    y_cap[i] = 1
  if y_cap[i]!=train_labels_35_hw3[i]:
    loss = loss + 1


for i in range(len(test_images_35_hw3)):
  if np.sum((theta.T*test_images_35_hw3[i])) >=0:
    y_cap_test[i] = 0 
  else:
    y_cap_test[i] = 1
  if y_cap_test[i]!=test_labels_35_hw3[i]:
    test_loss = test_loss + 1

testing_loss = test_loss/len(test_images_35_hw3)
training_loss = loss/len(train_images_35_hw3) 
print('The training loss is ' + str(training_loss))
print('The test loss is ' + str(testing_loss))

# print(theta)
'''



#Stochastic Gradient 
i = 0
flag = 0
new_l_count = 0
index = np.arange(train_images_35_hw3.shape[0])
np.random.shuffle(index)
train_images_35_hw3 = train_images_35_hw3[index]
train_labels_35_hw3 = train_labels_35_hw3[index]
# print(x)
# print(y)

# x= (theta.T*train_images_35_hw3[i])
# h_theta = 1/(1 + np.exp(-x))
# y= np.sum((train_labels_35_hw3[i] - h_theta)*train_images_35_hw3[i])
i = 0
# j = 0
# n = 0
while flag==0:
  for i in range(len(train_images_35_hw3)):
    x= (theta.T*train_images_35_hw3[i])
    h_theta = 1/(1 + np.exp(-x))
    y= ((train_labels_35_hw3[i] - h_theta)*train_images_35_hw3[i])
    # print(y)
    theta = theta + (alpha*y)
    if i ==200 or 400 or 800 or 1000 or 1200 or 1400 or 1600 or 1800 or 2000:
      # print(new_l_count)
      for i in range(len(train_images_35_hw3)):
        x= (theta.T*train_images_35_hw3[i])
        h_theta = 1/(1 + np.exp(-x))
        # print(h_theta)
        delta_theta = np.array([((train_labels_35_hw3[i] - h_theta)*train_images_35_hw3[i])]).sum()  
      # print(delta_theta)
      # theta = theta + (alpha*delta_theta)
      print(delta_theta)
      if abs(delta_theta) <= 0.01:
        flag = 1
        break 
        # index = np.arange(train_images_35_hw3.shape[0])
        # np.random.shuffle(index)
        # train_images_35_hw3 = train_images_35_hw3[index]
        # train_labels_35_hw3 = train_labels_35_hw3[index]
print(theta)'''